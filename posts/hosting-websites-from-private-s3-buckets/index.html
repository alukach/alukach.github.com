<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hosting websites from private S3 buckets | anthony lukach</title>
<meta name=keywords content="aws,s3"><meta name=description content="At work, we were alerted to an outage of an S3-backed frontend. The frontend was returning 403 responses. This left us scratching our head, as no deployment had occurred recently. After doing some digging, we found that AWS account administrators had applied a new policy to make all S3 buckets private (this is an account-wide setting, overriding bucket-level settings). 🆒 🆒 🆒
So how can we configure Cloudfront to access private S3 buckets?"><meta name=author content><link rel=canonical href=https://alukach.com/posts/hosting-websites-from-private-s3-buckets/><link crossorigin=anonymous href=/assets/css/stylesheet.1ed26481d325120f9a3f0ae345a661a48b2f3cff0b5eed3b700edd10d22d4d79.css integrity="sha256-HtJkgdMlEg+aPwrjRaZhpIsvPP8LXu07cA7dENItTXk=" rel="preload stylesheet" as=style><link rel=icon href=https://alukach.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://alukach.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://alukach.com/favicon-32x32.png><link rel=apple-touch-icon href=https://alukach.com/apple-touch-icon.png><link rel=mask-icon href=https://alukach.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://alukach.com/posts/hosting-websites-from-private-s3-buckets/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Hosting websites from private S3 buckets"><meta property="og:description" content="At work, we were alerted to an outage of an S3-backed frontend. The frontend was returning 403 responses. This left us scratching our head, as no deployment had occurred recently. After doing some digging, we found that AWS account administrators had applied a new policy to make all S3 buckets private (this is an account-wide setting, overriding bucket-level settings). 🆒 🆒 🆒
So how can we configure Cloudfront to access private S3 buckets?"><meta property="og:type" content="article"><meta property="og:url" content="https://alukach.com/posts/hosting-websites-from-private-s3-buckets/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-19T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-19T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hosting websites from private S3 buckets"><meta name=twitter:description content="At work, we were alerted to an outage of an S3-backed frontend. The frontend was returning 403 responses. This left us scratching our head, as no deployment had occurred recently. After doing some digging, we found that AWS account administrators had applied a new policy to make all S3 buckets private (this is an account-wide setting, overriding bucket-level settings). 🆒 🆒 🆒
So how can we configure Cloudfront to access private S3 buckets?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://alukach.com/posts/"},{"@type":"ListItem","position":2,"name":"Hosting websites from private S3 buckets","item":"https://alukach.com/posts/hosting-websites-from-private-s3-buckets/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hosting websites from private S3 buckets","name":"Hosting websites from private S3 buckets","description":"At work, we were alerted to an outage of an S3-backed frontend. The frontend was returning 403 responses. This left us scratching our head, as no deployment had occurred recently. After doing some digging, we found that AWS account administrators had applied a new policy to make all S3 buckets private (this is an account-wide setting, overriding bucket-level settings). 🆒 🆒 🆒\nSo how can we configure Cloudfront to access private S3 buckets?","keywords":["aws","s3"],"articleBody":"At work, we were alerted to an outage of an S3-backed frontend. The frontend was returning 403 responses. This left us scratching our head, as no deployment had occurred recently. After doing some digging, we found that AWS account administrators had applied a new policy to make all S3 buckets private (this is an account-wide setting, overriding bucket-level settings). 🆒 🆒 🆒\nSo how can we configure Cloudfront to access private S3 buckets? After a bit of experimentation, here are my findings:\nWhen using a Cloudfront Distribution, you can not use an Origin Access Control (OAC) to connect to a private S3 bucket’s website endpoint (i.e. {bucket_name}.s3-website-{bucket_region}.amazonaws.com). When using a Cloudfront Distribution, you can use an Origin Access Control (OAC) to connect to a private S3 bucket’s non-website endpoint (i.e. {bucket_name}.s3.{bucket_region}.amazonaws.com), however you lose some of the functionality that the S3 website endpoint brings such as the handling of routes without extensions (i.e. a request to /foo will not load /foo/index.html). Some notes Allegedly, the legacy Cloudfront WebDistribution allowed using an Origin Access Identity (OAI) with website buckets (source), however this is now deprecated in favor of the Cloudfront Distribution API and does not appear to be available via the AWS Console UI. The server handling of routes without extensions can be recreated for non-website S3 origins by use of a viewer-request Cloudfront Function (code) Some docs seem to suggest that you must set a “Default root object” on the entire distribution when serving an S3 origin, but in my experimentation this appears to be a solution for only root-level path rewriting (i.e. requests to / are sent to /index.html) but will not aide in adding the same logic to nested pathed (e.g. requests to /foo/ will not be sent to /foo/index.html). If a custom CF function is used to perform the path rewriting, a “Default root object” does not appear to be necessary. TLDR Therefore, to host an S3 website from a private S3 bucket via Cloudfront, one must:\nCreate a Cloudfront Origin pointing to the S3 non-website endpoint (i.e. {bucket_name}.s3.{bucket_region}.amazonaws.com) Create an Origin Access Control Update the S3 bucket with a policy permitting the OAC access (Cloudfront will provide you with this policy) Add a viewer-request Cloudfront Function that rewrites requests to endpoints without extensions. See below for code that will handle this rewrite. Note that it does not replicate the redirect-header functionality that S3 website buckets offer. That is okay in most cases. function handler(event) { var request = event.request; var uri = request.uri; // Check whether the URI is missing a file name. if (uri.endsWith('/')) { request.uri += 'index.html'; } // Check whether the URI is missing a file extension. else if (!uri.includes('.')) { request.uri += '/index.html'; } return request; } [!WARNING]\nThe above technique is not a panacea by any means. There may be situations where this falls short for an applications needs. When looking at whether a static website can be hosted via a private bucket, consider the following:\nRoutes without file paths: We need server-side logic to take requests to endpoints like /about and direct that lookup to /about/index.html. This is achievable via S3’s website endpoint or a CF function that adds that logic. QA tip: Be sure to thoroughly test this, you may be able to navigate from example.com/ to example.com/about because React.JS is handling the route navigation at that point, but does the website work if you type in the URL? Dynamic routes: the trick for supporting dynamic routes (e.g. /articles/{article-id}) in an SPA on S3 is to use a custom error page that serves the application (for more info, see “Single Page Applications” of this post). This is achievable via S3’s website endpoint, but not for a CF function unless something very clever is done. This issue won’t apply to websites that are fully statically generate (ie SSG, such as some Gatsby or NextJS applications). I don’t think this is reasonably possible for private buckets. Redirects: S3’s website endpoint has a feature where it will return any object with the x-amz-website-redirect-location metadata property as a 302 redirect to a new location. This will be lost when not using the S3 website endpoint unless a custom viewer-response CF function is implemented. Custom Error Page: S3’s website endpoint has a feature where it will return a user-specified document as a 404 document for any object that is requested but not found. This is the basis of the dynamic-route trick mentioned above. Even when not relying on the dynamic-route trick, it is nice to serve a user a well-formatted error page to inform them that they have followed a bad route. When using the S3 non-website endpoint, an XML-formatted error will instead be served. Cloudfront does have the ability to serve a custom user-specified custom error pages (e.g. 404s) for the entire distribution, however this is very likely non-ideal in that we may not want to serve the same format of 404 for a JSON-based REST API as we would for a HTML-based web application (for more info, see “Single Page Applications” of this post) ","wordCount":"843","inLanguage":"en","datePublished":"2024-04-19T00:00:00Z","dateModified":"2024-04-19T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://alukach.com/posts/hosting-websites-from-private-s3-buckets/"},"publisher":{"@type":"Organization","name":"anthony lukach","logo":{"@type":"ImageObject","url":"https://alukach.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://alukach.com/ accesskey=h title="anthony lukach (Alt + H)">anthony lukach</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://alukach.com/categories/posts title=Posts><span>Posts</span></a></li><li><a href=https://alukach.com/categories/snippets title=Snippets><span>Snippets</span></a></li><li><a href=https://alukach.com/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://alukach.com/resume title=Résumé><span>Résumé</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Hosting websites from private S3 buckets</h1><div class=post-meta><span title='2024-04-19 00:00:00 +0000 UTC'>April 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;|&nbsp;<a href=https://github.com/alukach/alukach.github.io/edit/main/content/posts/hosting-websites-from-private-s3-buckets.md rel="noopener noreferrer" target=_blank>Edit</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#so-how-can-we-configure-cloudfront-to-access-private-s3-buckets aria-label="So how can we configure Cloudfront to access private S3 buckets?">So how can we configure Cloudfront to access private S3 buckets?</a><ul><li><a href=#some-notes aria-label="Some notes">Some notes</a></li></ul></li><li><a href=#tldr aria-label=TLDR>TLDR</a></li></ul></div></details></div><div class=post-content><p>At work, we were alerted to an outage of an S3-backed frontend. The frontend was returning 403 responses. This left us scratching our head, as no deployment had occurred recently. After doing some digging, we found that AWS account administrators had applied a new policy to make all S3 buckets private (this is an account-wide setting, overriding bucket-level settings). 🆒 🆒 🆒</p><h3 id=so-how-can-we-configure-cloudfront-to-access-private-s3-buckets>So how can we configure Cloudfront to access private S3 buckets?<a hidden class=anchor aria-hidden=true href=#so-how-can-we-configure-cloudfront-to-access-private-s3-buckets>#</a></h3><p>After a bit of experimentation, here are my findings:</p><ul><li>When using a Cloudfront Distribution, you can not use an Origin Access Control (OAC) to connect to a private S3 bucket’s <em>website endpoint</em> (i.e. <code>{bucket_name}.s3-website-{bucket_region}.amazonaws.com</code>).</li><li>When using a Cloudfront Distribution, you can use an Origin Access Control (OAC) to connect to a private S3 bucket’s non-website endpoint (i.e. <code>{bucket_name}.s3.{bucket_region}.amazonaws.com</code>), however you lose some of the functionality that the S3 website endpoint brings such as the handling of routes without extensions (i.e. a request to <code>/foo</code> will not load <code>/foo/index.html</code>).</li></ul><h4 id=some-notes>Some notes<a hidden class=anchor aria-hidden=true href=#some-notes>#</a></h4><ul><li>Allegedly, the legacy Cloudfront <code>WebDistribution</code> allowed using an Origin Access Identity (OAI) with website buckets (<a href=https://repost.aws/questions/QUnzTuF8y7StOBK-QY_RTGkA/oai-or-not-oai-for-serving-a-static-website-in-s3-using-cloudfront#ANDedpud0CTnSqi4WNRUr_LQ>source</a>), however this is now deprecated in favor of the Cloudfront <code>Distribution</code> API and does not appear to be available via the AWS Console UI.</li><li>The server handling of routes without extensions can be recreated for non-website S3 origins by use of a viewer-request Cloudfront Function (<a href=https://stackoverflow.com/questions/31017105/how-do-you-set-a-default-root-object-for-subdirectories-for-a-statically-hosted/69157535#69157535>code</a>)</li><li>Some docs seem to suggest that you must set a “Default root object” on the entire distribution when serving an S3 origin, but in my experimentation this appears to be a solution for only root-level path rewriting (i.e. requests to <code>/</code> are sent to <code>/index.html</code>) but will not aide in adding the same logic to nested pathed (e.g. requests to <code>/foo/</code> will not be sent to <code>/foo/index.html</code>). If a custom CF function is used to perform the path rewriting, a &ldquo;Default root object&rdquo; does not appear to be necessary.</li></ul><h3 id=tldr>TLDR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h3><p>Therefore, to host an S3 website from a private S3 bucket via Cloudfront, one must:</p><ol><li>Create a Cloudfront Origin pointing to the S3 non-website endpoint (i.e. <code>{bucket_name}.s3.{bucket_region}.amazonaws.com</code>)</li><li>Create an Origin Access Control</li><li>Update the S3 bucket with a policy permitting the OAC access (Cloudfront will provide you with this policy)</li><li>Add a <code>viewer-request</code> Cloudfront Function that rewrites requests to endpoints without extensions. See below for code that will handle this rewrite. <em>Note that it does not replicate the redirect-header functionality that S3 website buckets offer. That is okay in most cases.</em><pre tabindex=0><code>function handler(event) {
    var request = event.request;
    var uri = request.uri;

    // Check whether the URI is missing a file name.
    if (uri.endsWith(&#39;/&#39;)) {
        request.uri += &#39;index.html&#39;;
    } 
    // Check whether the URI is missing a file extension.
    else if (!uri.includes(&#39;.&#39;)) {
        request.uri += &#39;/index.html&#39;;
    }

    return request;
}
</code></pre></li></ol><blockquote><p>[!WARNING]</p><p>The above technique is not a panacea by any means. There may be situations where this falls short for an applications needs. When looking at whether a static website can be hosted via a private bucket, consider the following:</p><ol><li><strong>Routes without file paths:</strong> We need server-side logic to take requests to endpoints like <code>/about</code> and direct that lookup to <code>/about/index.html</code>. This is achievable via S3&rsquo;s website endpoint or a CF function that adds that logic. <em>QA tip</em>: Be sure to thoroughly test this, you may be able to navigate from <a href=http://example.com/>example.com/</a> to <a href=http://example.com/about>example.com/about</a> because React.JS is handling the route navigation at that point, but does the website work if you type <code>&lt;https://example.com/about></code> in the URL?</li><li><strong>Dynamic routes:</strong> the trick for supporting dynamic routes (e.g. <code>/articles/{article-id}</code>) in an SPA on S3 is to use a custom error page that serves the application (for more info, see &ldquo;Single Page Applications&rdquo; of <a href=/posts/using-cloudfont-as-a-reverse-proxy/>this post</a>). This is achievable via S3&rsquo;s website endpoint, but not for a CF function unless something very clever is done. This issue won&rsquo;t apply to websites that are fully statically generate (ie SSG, such as some Gatsby or NextJS applications). <strong>I don&rsquo;t think this is reasonably possible for private buckets.</strong></li><li><strong>Redirects:</strong> S3&rsquo;s website endpoint has a feature where it will return any object with the <code>x-amz-website-redirect-location</code> metadata property as a <code>302</code> redirect to a new location. This will be lost when not using the S3 website endpoint unless a custom <code>viewer-response</code> CF function is implemented.</li><li><strong>Custom Error Page:</strong> S3&rsquo;s website endpoint has a feature where it will return a user-specified document as a 404 document for any object that is requested but not found. This is the basis of the dynamic-route trick mentioned above. Even when not relying on the dynamic-route trick, it is nice to serve a user a well-formatted error page to inform them that they have followed a bad route.  When using the S3 non-website endpoint, an XML-formatted error will instead be served.  Cloudfront does have the ability to serve a custom user-specified custom error pages (e.g. 404s) for the entire distribution, however this is very likely non-ideal in that we may not want to serve the same format of 404 for a JSON-based REST API as we would for a HTML-based web application (for more info, see &ldquo;Single Page Applications&rdquo; of <a href=/posts/using-cloudfont-as-a-reverse-proxy/>this post</a>)</li></ol></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://alukach.com/tags/aws/>Aws</a></li><li><a href=https://alukach.com/tags/s3/>S3</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://alukach.com/>anthony lukach</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>